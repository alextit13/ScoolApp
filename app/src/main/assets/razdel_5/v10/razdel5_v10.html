<!DOCTYPE html>
<!-- Template by quackit.com -->
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>v10</title>
	
	
</head>
	<style>
		body {
            background-image:url(file:///android_res/drawable/pict.jpg);
			color: aliceblue;
		}
	</style>

	<body>
<p style="text-indent:25px;"><strong>Класс</strong> называется абстрактным, если он имеет хотя бы один абстрактный метод.
</p>

<p style="text-indent:25px;"><strong>Метод</strong> называется абстрактным, если при определении метода задана его сигнатура, но не задана реализация метода.
</p>

<p style="text-indent:25px;">Объявление абстрактных методов и абстрактных классов должно сопровождаться модификатором <em>abstract</em>. Поскольку абстрактные классы не являются полностью определенными классами, то нельзя создавать объекты абстрактных классов. 
Абстрактные классы могут иметь потомков, частично или полностью реализующих абстрактные методы родительского класса. 
Абстрактный метод чаще всего рассматривается как виртуальный метод, переопределяемый потомком, поэтому к ним применяется стратегия динамического связывания. 
</p>

<p style="text-indent:25px;">Абстрактные классы используются при работе со структурами данных, предназначенными для хранения объектов одной иерархии, и в качестве параметров методов. Если класс, производный от абстрактного, не переопределяет все абстрактные методы, 
он также должен описываться как абстрактный. Можно создать метод, параметром которого является абстрактный класс. На место этого параметра при выполнении программы может передаваться объект любого производного класса. Это позволяет создавать полиморфные методы, работающие с объектом любого типа в пределах одной иерархии.
</p>

<p style="text-indent:25px;"><strong>Интнерфейсы</strong><br>
Интерфейс является «крайним случаем» абстрактного класса. В нем задается набор абстрактных методов, свойств и индексаторов, которые должны быть реализованы в производных классах. Интерфейс определяет поведение, которое поддерживается реализующими этот интерфейс классами. Основная идея использования интерфейса состоит в том, чтобы к объектам таких классов можно было обращаться одинаковым образом.
</p>

<p style="text-indent:25px;">
Каждый класс может определять элементы интерфейса по-своему. Так достигается полиморфизм: объекты разных классов по-разному реагируют на вызовы одного и того же метода. Синтаксис интерфейса аналогичен синтаксису класса: [ атрибуты ] [ спецификаторы ] interface имя_интерфейса [ : предки ] телоинтерфейса [ ; ] 
</p>

<p style="text-indent:25px;">
Для интерфейса могут быть указаны спецификаторы: <em>new, publiс, protected, internal</em> и <em>private</em>. Спецификатор <em>new</em> применяется для вложенных интерфейсов и имеет такой же смысл, как и соответствующий модификатор метода класса. Остальные спецификаторы управляют видимостью интерфейса. В разных контекстах определения интерфейса допускаются разные спецификаторы. По умолчанию интерфейс доступен только из сборки, в которой он описан (<em>internal</em>).
</p>

<p style="text-indent:25px;"><strong>Использованная литература:</strong></p>
1) В.А. Биллинг. Основы программирования на C#: учебное пособие. – М.: НОУ ИНТУИТ, 2006;
2) Т.А. Павловская. C#. Программирование на языке высокого уровня: учебник для вузов. - С-ПБ.: Питер, 2009

</body>
</html>